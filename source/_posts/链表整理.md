---
title: 链表总结
date : 2020-7-23 22:09:13
tags: ["LeetCode", "链表",]
---
整理了链表长见的面试算法：
    1.链表反转
    2.循环链表
    3.反转合并链表
    4.倒数第K个元素
<!--more-->
1.反转链表
  https://leetcode-cn.com/problems/reverse-linked-list/
```
/*
 * @lc app=leetcode.cn id=206 lang=cpp
 *
 * [206] 反转链表
 * 创建一个新链表的头部
 * 1.备份一下head->next; ListNode *temp = head->next;
 * 2.修改head->next; head->next = new_head;
 * 3.修改new_head; new_head = head;
 * 4.修改head; head = temp;
 */
/**
 * Definition for singly-linked list.
 */
#include<stdio.h>
#include<iostream>
#include<vector>
using namespace std;

// struct ListNode {
//     int val;
//     ListNode *next;
//     ListNode(int x) : val(x), next(NULL) {}
// };


class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *new_header = NULL;//新链表的头结点指针
        while (head)
        {
            ListNode *next = head->next;//备份head_next
            head->next=new_header;//更新head_next
            new_header = head;//移动new_header
            head = next;//遍历链表
        }
        return new_header;
    }
};
```
2.判断链表含环
  https://leetcode-cn.com/problems/linked-list-cycle-ii/
```
/*
 * @lc app=leetcode.cn id=142 lang=cpp
 *
 * [142] 环形链表 II
 * 快慢指针赛跑
 */
/**
 * Definition for singly-linked list.
  */
#include<stdio.h>
#include<iostream>
#include<vector>
using namespace std;
//  struct ListNode {
//     int val;
//     ListNode *next;
//     ListNode(int x) : val(x), next(NULL) {}
// };

class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *fast = head;
        ListNode *slow = head;
        ListNode *meet = NULL;
        while (fast)
        {
            slow = slow->next;
            fast = fast->next;
            if (!fast){
                return NULL;
            }
            fast = fast ->next;
            if (fast == slow){
                meet = fast;
                break;
            }
        }
        if (meet == NULL){
            return NULL;
        }
        while (head && meet)
        {
            if (meet == head){
                return head;
            }
            head = head->next;
            meet = meet->next;
        }
        return NULL;
        
    }
};
```
3.K个一组翻转链表
 https://leetcode-cn.com/problems/reverse-nodes-in-k-group/
 ```
#include<stdio.h>
#include<stack>
#include<iostream>
using namespace std;


 struct ListNode {
      int val;
      ListNode *next;
      ListNode(int x) : val(x), next(NULL) {}
 };
 
class Solution {
public:
	pair<ListNode*, ListNode*> myReverse(ListNode* head, ListNode* tail) {
		ListNode* prev = tail->next;
		ListNode* p = head;
		while (prev != tail) {
			ListNode* nex = p->next;
			p->next = prev;
			prev = p;
			p = nex;
		}
		return { tail, head };
	}

	ListNode* reverseKGroup(ListNode* head, int k) {
		ListNode* hair = new ListNode(0);
		hair->next = head;
		ListNode* pre = hair;

		while (head) {
			ListNode* tail = pre;
			// 查看剩余部分长度是否大于等于 k
			for (int i = 0; i < k; ++i) {
				tail = tail->next;
				if (!tail) {
					return hair->next;
				}
			}
			ListNode* nex = tail->next;
			pair<ListNode*, ListNode*> result = myReverse(head, tail);
			head = result.first;
			tail = result.second;
			// 把子链表重新接回原链表
			pre->next = head;
			tail->next = nex;
			pre = tail;
			head = tail->next;
		}
		return hair->next;
	}
};
 ```
4.倒数第K个结点(快慢指针)
https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/
p,q 都指向head
1.第一个指针p先走K步
2.p，q同时走，当p为空的时候跳出循环，返回q
```
class Solution(object):
    def getKthFromEnd(self, head, k):
        """
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """
        new_head = ListNode(-1)
        new_head.next = head
        p = new_head
        q = new_head
        while p:
            if k > 0:
                p = p.next
                k = k - 1
            else:
                q = q.next
                p = p.next
        return q

```
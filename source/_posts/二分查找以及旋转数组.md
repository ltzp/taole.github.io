---
title: 二分查找以及旋转数组
date: 2019-11-15 21:02:38
tags: ['LeetCode', '二分查找', '旋转数组']
---
二分查找:对于一个已经排序好的数组进行进行查询，时间复杂度是O(log2n),实现方法可以是递归,也可以是循环。
旋转数组:前面一半有序,后面一半有序:例如[3,4,5,6,1,2].一般用于求查找是否存在,以及最小的元素。
旋转数组最重要的判断条件是nums[begin]和nums[mid]的比较关系
题目:
&emsp;https://leetcode-cn.com/problems/search-in-rotated-sorted-array/
&emsp;https://www.nowcoder.com/ta/coding-interviews 旋转数组最小值
<!--more-->
![](complain.png)
```
class Solution {
public:
    int search(vector<int>& nums, int target) {

		int length = nums.size();
		int begin = 0, end = length - 1;
		while (begin <= end)
		{
			int mid = (begin + end) / 2;
			if (target == nums[mid]) //存在的话直接返回
			{
                return mid;
			}
			else if (target < nums[mid])
			{
				if (nums[begin] < nums[mid]) //begin-mid 是单调递增的
				{
					if (target >= nums[begin]) //在递增的范围内搜寻
					{
						end = mid - 1;
					}
					else                        //在反转的部分搜寻
					{
						begin = mid + 1;
					}
				}
				else if(nums[begin] > nums[mid])//mid在旋转部分
				{
					end = mid - 1;
				}
				else if(nums[begin] == nums[mid])
				{
					begin = mid + 1;
				}	
			}
			else if (target > nums[mid])
			{
				if (nums[begin] < nums[mid])
				{
					begin = mid + 1;
				}
				else if (nums[begin] > nums[mid])
				{
					if (target >= nums[begin])
					{
						end = mid - 1;
					}
					else
					{
						begin = mid + 1;
					}
					
				}
				else if (nums[begin] == nums[mid])
				{
					begin = mid + 1;
				}
			}

		}
		return -1;        
    }
};
```

